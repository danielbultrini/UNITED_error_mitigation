# %%
from math import gamma
from numpy.lib import take_along_axis
import scipy.io as sio
import numpy as np
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
from scipy.io import savemat
from sklearn import linear_model
import pandas as pd
import os
import qutip as q
from datetime import datetime

# %%


class VD_CDR:
    """Class to compute all error mitigation techniques for our paper. One must always
    initialize and then one has the option to either autoprocess everything or load the data via load_data()
    and then run each desired technique separately. No function returns anything, everything is written to
    internal dictionaries and dataframes.
    """

    def __init__(
        self,
        Q,
        p,
        num_seeds,
        N,
        Nts,
        max_copies,
        nlsp_list,
        shots=[None, 100000],
        folder="",
        extra_tags=[""],
        autoprocessing=True,
        density_matrices=False,
        train=True,
        budget=0,
        train_use=100,
    ):
        """Computations on VD and CDR data generated by LANL MATLAB code at variable noise levels.
        The data format must be, for the 'Circuit of Interest' - the one you want to correct - a multi indexed array with
        1*1 expectation value (expected) - 1*1 expectation value (noisy) - 1*max_copies array expectation value (expected) - 1*max_copies array expectation value (noisy)
        The training data is in the format

        With a name in the format of coi_data_Q{number of qubits}p{depth, 0}MC{max number of copies}nlsp{noise level of simulation}seed{simulation_seed}.mat
        Followed by the shot array with a name coi_data_Q{number of qubits}p{depth, 0}MC{max number of copies}nlsp{noise level of simulation}seed{simulation_seed}shots{number of shots}.mat
        additional tags at the end are allowed.
        Training data is in a similar format
        train_data_Q{number of qubits}p{depth, 0}N{non_clifford gate number}Nts{size of training set}MC{max number of copies}nlsp{noise level of simulation}seed{simulation_seed}.mat
        train_data_Q{number of qubits}p{depth, 0}N{non_clifford gate number}Nts{size of training set}MC{max number of copies}nlsp{noise level of simulation}seed{simulation_seed}shots{number of shots}.mat
        Args:
            Q (int): number of qubits in circuit
            p (int): depth of circuit
            num_seeds (int): number of different seeds of circuit you want to consider
            N (int): number of non clifford gates in circuit
            Nts (int): number of training sets
            max_copies (int): number of VD copies available
            nlsp_list (list[str]): list of noise levels considered, could be float
            shots (list[None,int], optional): List of shots you want to consider, None is infinite. Defaults to [None,100000].
            folder (str, optional): folder where data is stored, must end with /. Defaults to ''.
            extra_tags (list, optional): list of tags you may have for filenames (must be at end of filename). Defaults to [''].
            autoprocessing (bool, optional): Calculates all possible values and produces pandas dataframe for you. Defaults to True.
            density_matrices (bool, optional): calculates values realted to density matrices. Defaults to True.
            train (bool, optional): sets if training data and techniques are priocessed. Defaults to True.
            budget (int, optional): sets budget for particular processing set. Defaults to 0.
            train_use (int, optional): How many training samples to actually use - these are selected according to largest magnitude. Defaults to 100.
        """
        self.budget = budget
        if budget != 0:  # old log file D:/Databases/VD_CDR/LOGS/
            self.log_file = open(
                "./log2/"
                + f"log_tag{extra_tags[0]}_Q{Q}p{p}B{int(np.log10(budget))}.txt",
                "w",
            )
            self.missing_file = open(
                "./log2/"
                + f"MISSING{extra_tags[0]}_Q{Q}p{p}B{int(np.log10(budget))}.txt",
                "w",
            )

        else:
            self.log_file = open(
                "./log2/" + f"log_tag{extra_tags[0]}_Q{Q}p{p}B0.txt", "w"
            )
            self.missing_file = open(
                "./log2/" + f"MISSING{extra_tags[0]}_Q{Q}p{p}B0.txt", "w"
            )
        self.train_use = train_use
        self.train = train
        self.Q = Q
        self.p = p
        self.num_seeds = num_seeds
        self.N = N
        self.Nts = Nts
        self.max_copies = max_copies
        self.nlsp_list = nlsp_list
        self.folder = folder
        self.shots = shots
        self.num_noise_levels = len(nlsp_list)
        self.ms = np.linspace(1, self.max_copies, self.max_copies)
        self.density_matrices = density_matrices
        self.extra_tags = extra_tags
        self.train_obsex = np.zeros(
            (
                len(self.extra_tags),
                len(shots),
                self.num_noise_levels,
                self.num_seeds,
                self.train_use,
            )
        )
        self.train_obsm_unprocessed = np.zeros(
            (
                len(self.extra_tags),
                len(shots),
                self.num_noise_levels,
                self.num_seeds,
                self.train_use,
                self.max_copies,
            )
        )
        self.coi_obsex = np.zeros(
            (len(self.extra_tags), len(shots), self.num_noise_levels, self.num_seeds)
        )
        self.coi_obsm_unprocessed = np.zeros(
            (
                len(self.extra_tags),
                len(shots),
                self.num_noise_levels,
                self.num_seeds,
                self.max_copies,
            )
        )
        self.data_dict = {}
        list_of_vals = [
            "CGVD",
            "train_obsex",
            "train_obsm",
            "coi_obsex",
            "coi_obsm",
            "UNITED",
            "density_ideal",
            "density_noisy",
            "coherent_mismatch",
            "noise_floor",
            "eigenvalue_ratio",
        ]
        columns = [
            "result_type",
            "tag",
            "shots",
            "nlsp",
            "seed",
            "qubits",
            "copies",
            "expectation",
            "exact",
        ]
        self.coi_panda = pd.DataFrame(columns=columns)
        self.train_panda = pd.DataFrame(columns=columns)
        for vals in list_of_vals:
            self.data_dict[vals] = {}
            for tag in self.extra_tags:
                self.data_dict[vals][tag] = {}
                for shot in self.shots:
                    self.data_dict[vals][tag][str(shot)] = {}
                    for noise_level in self.nlsp_list:
                        self.data_dict[vals][tag][str(shot)][noise_level] = {}
                        for seed in range(self.num_seeds):
                            self.data_dict[vals][tag][str(shot)][noise_level][seed] = []
        if autoprocessing:
            self.autoprocessing()

    def autoprocessing(self):
        self.load_data()
        if self.train:
            self.ZNE_data()
            self.CGVD_data()
            self.vnCDR_cp_nlsp_data()
            self.simple_CDR_data()
        self.VD_data()
        self.build_panda()

    def load_data(self):
        """function to load the data neccesary for the mitigation methods.
        Args:
        Q: number qubits.
        p: depth
        N: number non Cliffords.
        Nts: number of training cirucits.
        max_copies: maximum number of copies.
        nlsp: noise level of state preperation.
        shots: number of shots.
        returns:
        train_obsex: exact observable training data. np.ndarray
                     dimensionality num_seeds * Nts
        train_obsm : noisy and mitigated observables data np.ndarray
                     dimensionality num_seeds * Nts * max_copies.
                     train_obsm[:,:,0] is the noisy data (1 copy VD).
        coi_obsex: exact observable for circuit of interest. dim num_seeds
        coi_obsm: mitigated observable of interest dim num_seeds * max_copies
        """
        sig_x = q.tensor(
            q.tensor(q.sigmax(), q.sigmax()), q.tensor(q.sigmax(), q.sigmax())
        )
        for seed_i in range(self.num_seeds):
            for nlsp_no, nlsp in enumerate(self.nlsp_list):
                for index, shot_type in enumerate(self.shots):
                    for tag_i, tag in enumerate(self.extra_tags):
                        try:
                            if shot_type == None:
                                if self.train:
                                    train_data = sio.loadmat(
                                        self.folder
                                        + "train_data_Q{}p{}N{}Nts{}MC{}nlsp{}seed{}{}.mat".format(
                                            self.Q,
                                            self.p,
                                            self.N,
                                            self.Nts,
                                            self.max_copies,
                                            nlsp,
                                            seed_i,
                                            tag,
                                        )
                                    )
                                coi_data = sio.loadmat(
                                    self.folder
                                    + "coi_data_Q{}p{}MC{}nlsp{}seed{}{}.mat".format(
                                        self.Q,
                                        self.p,
                                        self.max_copies,
                                        nlsp,
                                        seed_i,
                                        tag,
                                    )
                                )
                            else:
                                if self.train:
                                    train_data = sio.loadmat(
                                        self.folder
                                        + "train_data_Q{}p{}N{}Nts{}MC{}nlsp{}seed{}shots{}{}.mat".format(
                                            self.Q,
                                            self.p,
                                            self.N,
                                            self.Nts,
                                            self.max_copies,
                                            nlsp,
                                            seed_i,
                                            shot_type,
                                            tag,
                                        )
                                    )
                                coi_data = sio.loadmat(
                                    self.folder
                                    + "coi_data_Q{}p{}MC{}nlsp{}seed{}shots{}{}.mat".format(
                                        self.Q,
                                        self.p,
                                        self.max_copies,
                                        nlsp,
                                        seed_i,
                                        shot_type,
                                        tag,
                                    )
                                )

                            if self.train:
                                train_obsex_1 = train_data["train_data"][0][0]
                                train_obsex_ = train_obsex_1[
                                    np.argsort(np.abs(train_obsex_1).flatten()[0:100])[
                                        ::-1
                                    ][: self.train_use]
                                ]
                                train_obsn_ = train_data["train_data"][0][1]
                                train_obsn_ = train_obsn_[
                                    np.argsort(np.abs(train_obsex_1).flatten()[0:100])[
                                        ::-1
                                    ][: self.train_use]
                                ]
                                p0_train = train_data["train_data"][0][2]
                                p0_train = p0_train[
                                    np.argsort(np.abs(train_obsex_1).flatten()[0:100])[
                                        ::-1
                                    ][: self.train_use]
                                ]
                                p0p_train = train_data["train_data"][0][3]
                                p0p_train = p0p_train[
                                    np.argsort(np.abs(train_obsex_1).flatten()[0:100])[
                                        ::-1
                                    ][: self.train_use]
                                ]

                            else:
                                train_obsex_ = np.ones((self.train_use, 1)) / 2
                                train_obsn_ = np.ones((self.train_use, 1)) / 2
                                p0_train = np.ones((self.train_use, 5)) / 2
                                p0p_train = np.ones((self.train_use, 5))

                            coi_obsex_ = coi_data["coi_data"][0][0]
                            coi_obsm_ = coi_data["coi_data"][0][
                                1
                            ]  
                            p0_coi = coi_data["coi_data"][0][2]
                            p0p_coi = coi_data["coi_data"][0][3]

                            self.train_obsex[
                                tag_i, index, nlsp_no, seed_i, :
                            ] = train_obsex_.flatten()
                            self.train_obsm_unprocessed[
                                tag_i, index, nlsp_no, seed_i, :, 0
                            ] = train_obsn_.flatten()

                            self.train_obsm_unprocessed[
                                tag_i, index, nlsp_no, seed_i, :, 1:
                            ] = (2 * p0p_train - 1) / (2 * p0_train - 1)
                            self.coi_obsex[tag_i, index, nlsp_no, seed_i] = coi_obsex_
                            self.coi_obsm_unprocessed[
                                tag_i, index, nlsp_no, seed_i, 0
                            ] = coi_obsm_.flatten()
                            # calculate values mitigated by VD on coi:
                            self.coi_obsm_unprocessed[
                                tag_i, index, nlsp_no, seed_i, 1:
                            ] = ((2 * p0p_coi - 1) / (2 * p0_coi - 1)).flatten()
                            self.data_dict["train_obsm"][tag][str(shot_type)][nlsp][
                                seed_i
                            ] = self.train_obsm_unprocessed[
                                tag_i, index, nlsp_no, seed_i
                            ]
                            self.data_dict["train_obsex"][tag][str(shot_type)][nlsp][
                                seed_i
                            ] = self.train_obsex[tag_i, index, nlsp_no, seed_i]
                            self.data_dict["coi_obsex"][tag][str(shot_type)][nlsp][
                                seed_i
                            ] = self.coi_obsex[tag_i, index, nlsp_no, seed_i]
                            self.data_dict["coi_obsm"][tag][str(shot_type)][nlsp][
                                seed_i
                            ] = self.coi_obsm_unprocessed[tag_i, index, nlsp_no, seed_i]
                            if self.density_matrices:
                                density_noisy = sio.loadmat(
                                    self.folder
                                    + "rhon_Q{}p{}MC{}nlsp{}seed{}{}.mat".format(
                                        self.Q,
                                        self.p,
                                        self.max_copies,
                                        nlsp,
                                        seed_i,
                                        tag,
                                    )
                                )
                                density_ideal = sio.loadmat(
                                    self.folder
                                    + "rhoEx_Q{}p{}MC{}nlsp{}seed{}{}.mat".format(
                                        self.Q,
                                        self.p,
                                        self.max_copies,
                                        nlsp,
                                        seed_i,
                                        tag,
                                    )
                                )
                                # self.density_ideal[tag_i,nlsp_no,seed_i] = density_ideal['rhoexact']
                                # self.density_noisy[tag_i,nlsp_no,seed_i] = density_noisy['rhonoisy']
                                self.data_dict["density_noisy"][tag][str(shot_type)][
                                    nlsp
                                ][seed_i] = q.Qobj(density_noisy["rhonoisy"])
                                self.data_dict["density_ideal"][tag][str(shot_type)][
                                    nlsp
                                ][seed_i] = q.Qobj(density_ideal["rhoexact"])

                                eigenstates = self.data_dict["density_noisy"][tag][
                                    str(shot_type)
                                ][nlsp][seed_i].eigenstates()
                                noisy_dominance = (
                                    eigenstates[0][-2] / eigenstates[0][-1]
                                )

                                state_i = q.Qobj(
                                    self.data_dict["density_ideal"][tag][
                                        str(shot_type)
                                    ][nlsp][seed_i].eigenstates()[1][-1]
                                )
                                state_n = q.Qobj(eigenstates[1][-1])
                                self.data_dict["coherent_mismatch"][tag][
                                    str(shot_type)
                                ][nlsp][seed_i] = (
                                    1 - abs(state_i.dag().overlap(state_n)) ** 2
                                )
                                self.data_dict["noise_floor"][tag][str(shot_type)][
                                    nlsp
                                ][seed_i] = abs(
                                    sig_x.matrix_element(state_n.dag(), state_n)
                                    - sig_x.matrix_element(state_i.dag(), state_i)
                                )
                                self.data_dict["eigenvalue_ratio"][tag][str(shot_type)][
                                    nlsp
                                ][seed_i] = noisy_dominance

                            if not os.path.exists(
                                f"{self.folder}pandas_train_Q{self.Q}p{self.p}N{self.N}Nts{self.Nts}MC{self.max_copies}.pkl"
                            ):
                                self.coi_panda = self.coi_panda.append(
                                    pd.DataFrame(
                                        {
                                            "result_type": "COI",
                                            "tag": tag,
                                            "shots": shot_type,
                                            "nlsp": nlsp,
                                            "seed": seed_i,
                                            "qubits": self.Q,
                                            "copies": list(
                                                range(1, self.max_copies + 1)
                                            ),
                                            "expectation": self.data_dict["coi_obsm"][
                                                tag
                                            ][str(shot_type)][nlsp][seed_i],
                                            "exact": self.data_dict["coi_obsex"][tag][
                                                str(shot_type)
                                            ][nlsp][seed_i],
                                        }
                                    ),
                                    ignore_index=True,
                                )
                                for copy_i in range(self.max_copies):
                                    self.train_panda = self.train_panda.append(
                                        pd.DataFrame(
                                            {
                                                "result_type": "train",
                                                "tag": tag,
                                                "shots": shot_type,
                                                "nlsp": nlsp,
                                                "seed": seed_i,
                                                "qubits": self.Q,
                                                "copies": copy_i + 1,
                                                "expectation": self.data_dict[
                                                    "train_obsm"
                                                ][tag][str(shot_type)][nlsp][seed_i][
                                                    :, copy_i
                                                ],
                                                "exact": self.data_dict["train_obsex"][
                                                    tag
                                                ][str(shot_type)][nlsp][seed_i],
                                            }
                                        ),
                                        ignore_index=True,
                                    )
                        except:
                            print(
                                f"FAILED qubit {self.Q},depth {self.p}, seed:{seed_i}, nlsp {nlsp},shots {shot_type}, tag: {tag}",
                                file=self.missing_file,
                            )
        if self.train:
            self.mask_train_obsm = np.logical_or(
                abs(self.train_obsm_unprocessed) > 1,
                (~np.isfinite(self.train_obsm_unprocessed)),
            )
            self.mask_coi_obsm = np.logical_or(
                abs(self.coi_obsm_unprocessed) > 1,
                (~np.isfinite(self.coi_obsm_unprocessed)),
            )
            self.train_obsm = self.train_obsm_unprocessed
            self.coi_obsm = self.coi_obsm_unprocessed
        else:
            self.mask_train_obsm = self.train_obsm_unprocessed
            self.mask_coi_obsm = self.coi_obsm_unprocessed
            self.train_obsm = self.train_obsm_unprocessed
            self.coi_obsm = self.coi_obsm_unprocessed
        if not os.path.exists(
            f"{self.folder}pandas_train_Q{self.Q}p{self.p}N{self.N}Nts{self.Nts}MC{self.max_copies}.pkl"
        ):
            self.train_panda = self.train_panda.set_index(
                ["result_type", "tag", "shots", "nlsp", "seed", "qubits", "copies"]
            )
            self.coi_panda = self.coi_panda.set_index(
                ["result_type", "tag", "shots", "nlsp", "seed", "qubits", "copies"]
            )
            self.train_panda.to_pickle(
                f"{self.folder}pandas_train_Q{self.Q}p{self.p}N{self.N}Nts{self.Nts}MC{self.max_copies}.pkl"
            )
            self.coi_panda.to_pickle(
                f"{self.folder}pandas_COI_Q{self.Q}p{self.p}N{self.N}Nts{self.Nts}MC{self.max_copies}.pkl"
            )

    def VD_data(self):
        """This module calculates the Virtual Distillation error mitigation technique for all present data and produces a dictionary with the results"""
        ms = np.linspace(1, self.max_copies, self.max_copies)
        self.VD_data_dict = {}
        self.exact_data_dict = {}
        for index, shots in enumerate(self.shots):
            self.exact_data_dict[str(shots)] = {}
            self.VD_data_dict[str(shots)] = {}
            for nlsp_no, nlsp in enumerate(self.nlsp_list):
                self.exact_data_dict[str(shots)][nlsp] = {}

                self.VD_data_dict[str(shots)][nlsp] = {}
                for tag_i, tag in enumerate(self.extra_tags):

                    self.VD_data_dict[str(shots)][nlsp][
                        "mit_value" + tag
                    ] = pd.DataFrame(
                        self.coi_obsm[tag_i, index, nlsp_no].transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )
                    temp_abs_err_calc = []
                    temp_exact = []
                    for seed in range(self.num_seeds):
                        temp_abs_err_calc.append(
                            abs(
                                self.coi_obsm[tag_i, index, nlsp_no, seed]
                                - self.coi_obsex[tag_i, index, nlsp_no, seed]
                            )
                        )
                        temp_exact.append(
                            self.coi_obsm[tag_i, index, nlsp_no, seed]
                            - self.coi_obsm[tag_i, index, nlsp_no, seed]
                            + self.coi_obsex[tag_i, index, nlsp_no, seed]
                        )
                    self.VD_data_dict[str(shots)][nlsp][
                        "abs_error" + tag
                    ] = pd.DataFrame(
                        np.array(temp_abs_err_calc).transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )
                    self.exact_data_dict[str(shots)][nlsp][
                        "exact_value" + tag
                    ] = pd.DataFrame(
                        np.array(temp_exact).transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )

    def f_lin(self, x, a0, a1):
        return a0 + a1 * x

    def f_exp(self, x, a, b, c):
        return a * (b ** (x)) + c

    def get_zne_corr_lin(self, x_test):
        """Code that returns the linear ansatz ZNE correction

        Args:
            x_test (np.array): Array with the noisy expectation value in ascending order

        Returns:
            int: ZNE mitigated expectation value
        """
        max_noise_level = x_test.size
        Y_train = x_test[:max_noise_level].T
        train_size = Y_train.size
        X_train = np.arange(1, train_size + 1, 1).astype(float)
        popt, _ = curve_fit(self.f_lin, X_train, Y_train)
        corr = popt[1]
        return corr

    def get_zne_corr_exp(self, x_test):
        """Code that returns the exponential ansatz ZNE correction

        Args:
            x_test (np.array): Array with the noisy expectation value in ascending order

        Returns:
            int: ZNE mitigated expectation value
        """

        max_noise_level = x_test.size
        Y_train = x_test[:max_noise_level].T
        train_size = Y_train.size
        X_train = np.arange(1, train_size + 1, 1).astype(float)
        popt, _ = curve_fit(self.f_exp, X_train, Y_train, maxfev=10000)
        corr = popt[0] + popt[2]
        return corr

    def ZNE_data(self):
        """Code that generates all ZNE correctino for 2 noise levels unless otherwise specified."""
        self.ZNE_lin2_array = np.zeros(
            (len(self.extra_tags), len(self.shots), self.num_seeds, self.max_copies)
        )
        self.ZNE_lin2_abs_error = np.zeros(
            (len(self.extra_tags), len(self.shots), self.num_seeds, self.max_copies)
        )
        self.ZNE_lin2_dict = {}
        for index, shot in enumerate(self.shots):
            self.ZNE_lin2_dict[str(shot)] = {}
            for tag_i, tag in enumerate(self.extra_tags):
                for seed in range(self.num_seeds):
                    for copy in range(self.max_copies):
                        x_test = self.coi_obsm[tag_i, index, :, seed, copy]
                        try:
                            zne_lin2_mit = self.get_zne_corr_lin(x_test[0:2])
                            self.ZNE_lin2_array[tag_i, index, seed, copy] = zne_lin2_mit
                        except:
                            print("ZNE FAIL AT:", file=self.log_file)
                            print(
                                f"tag: {tag}, shot: {shot} seed: {seed}, copy: {copy}",
                                file=self.log_file,
                            )
                            print(
                                self.coi_obsm[tag_i, index, :, seed, copy],
                                file=self.log_file,
                            )
                            self.ZNE_lin2_array[
                                tag_i, index, seed, copy
                            ] = self.coi_obsex[tag_i, index, 0, seed]
                        self.ZNE_lin2_abs_error[tag_i, index, seed, copy] = abs(
                            self.ZNE_lin2_array[tag_i, index, seed, copy]
                            - self.coi_obsex[tag_i, index, 0, seed]
                        )

                self.ZNE_lin2_dict[str(shot)]["mit_value" + tag] = pd.DataFrame(
                    self.ZNE_lin2_array[tag_i, index].transpose(),
                    columns=range(self.num_seeds),
                    index=range(1, self.max_copies + 1),
                )
                self.ZNE_lin2_dict[str(shot)]["abs_error" + tag] = pd.DataFrame(
                    self.ZNE_lin2_abs_error[tag_i, index].transpose(),
                    columns=range(self.num_seeds),
                    index=range(1, self.max_copies + 1),
                )

    def simple_CDR_data(self):
        """Generates data for all CDR"""
        self.cdr_mit_array = np.zeros(
            (
                len(self.extra_tags),
                len(self.shots),
                len(self.nlsp_list),
                self.num_seeds,
                self.max_copies,
            )
        )
        self.cdr_mit_abs_error = np.zeros(
            (
                len(self.extra_tags),
                len(self.shots),
                len(self.nlsp_list),
                self.num_seeds,
                self.max_copies,
            )
        )
        self.cdr_mit_dict = {}
        for index, shot in enumerate(self.shots):
            self.cdr_mit_dict[str(shot)] = {}
            for nlsp_no, nlsp in enumerate(self.nlsp_list):
                self.cdr_mit_dict[str(shot)][nlsp] = {}

        ms = np.linspace(1, self.max_copies, self.max_copies)
        for index, shot in enumerate(self.shots):
            for nlsp_no, nlsp in enumerate(self.nlsp_list):
                for tag_i, tag in enumerate(self.extra_tags):

                    for seed in range(self.num_seeds):

                        for copy in range(self.max_copies):
                            x_train1 = self.train_obsm[
                                tag_i, index, nlsp_no, seed, :, copy
                            ]
                            y_train1 = self.train_obsex[tag_i, index, nlsp_no, seed, :]
                            x_test = self.coi_obsm[tag_i, index, nlsp_no, seed, copy]
                            try:
                                cdr_mit = self.CDRMitigation(x_test, x_train1, y_train1)
                                self.cdr_mit_array[
                                    tag_i, index, nlsp_no, seed, copy
                                ] = cdr_mit[0][0]
                            except:
                                print("CDR FAIL AT:", file=self.log_file)
                                print(
                                    f"tag: {tag}, shot: {shot}, copy: {copy}, nlsp: {nlsp}, seed: {seed}",
                                    file=self.log_file,
                                )
                                print(x_train1, file=self.log_file)
                                print(y_train1, file=self.log_file)
                                print(x_test, file=self.log_file)
                                self.cdr_mit_array[
                                    tag_i, index, nlsp_no, seed, copy
                                ] = self.coi_obsex[tag_i, index, nlsp_no, seed]

                            self.cdr_mit_abs_error[
                                tag_i, index, nlsp_no, seed, copy
                            ] = abs(
                                self.cdr_mit_array[tag_i, index, nlsp_no, seed, copy]
                                - self.coi_obsex[tag_i, index, nlsp_no, seed]
                            )

                    self.cdr_mit_dict[str(shot)][nlsp][
                        "mit_value" + tag
                    ] = pd.DataFrame(
                        self.cdr_mit_array[tag_i, index, nlsp_no].transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )
                    self.cdr_mit_dict[str(shot)][nlsp][
                        "abs_error" + tag
                    ] = pd.DataFrame(
                        self.cdr_mit_abs_error[tag_i, index, nlsp_no].transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )

    def vnCDR_cp_nlsp_data(self):
        """Generates data for both vnCDR and UNITED techniques"""
        self.UNITED_cp_nlsp_dict = {}
        self.vnCDR_cp_nlsp_dict = {}

        self.UNITED_array = np.zeros(
            (len(self.extra_tags), len(self.shots), self.num_seeds, self.max_copies)
        )
        self.UNITED_abs_error = np.zeros(
            (len(self.extra_tags), len(self.shots), self.num_seeds, self.max_copies)
        )
        self.vnCDR_array = np.zeros(
            (len(self.extra_tags), len(self.shots), self.num_seeds, self.max_copies)
        )
        self.vnCDR_abs_error = np.zeros(
            (len(self.extra_tags), len(self.shots), self.num_seeds, self.max_copies)
        )

        for index, shot in enumerate(self.shots):
            self.UNITED_cp_nlsp_dict[str(shot)] = {}
            self.vnCDR_cp_nlsp_dict[str(shot)] = {}
            for tag_i, tag in enumerate(self.extra_tags):

                for seed in range(self.num_seeds):
                    ms = np.linspace(1, self.max_copies, self.max_copies)
                    noise_levels = len(self.nlsp_list)
                    train_obsex = np.zeros(
                        (self.num_seeds, self.train_use, noise_levels)
                    )
                    train_obsm = np.zeros(
                        (self.num_seeds, self.train_use, self.max_copies, noise_levels)
                    )
                    coi_obsex = np.zeros((self.num_seeds, noise_levels))
                    coi_obsm = np.zeros((self.num_seeds, self.max_copies, noise_levels))
                    for n in range(noise_levels):
                        train_obsex[:, :, n] = self.train_obsex[tag_i, index, n]
                        train_obsm[:, :, :, n] = self.train_obsm[tag_i, index, n]
                        coi_obsex[:, n] = self.coi_obsex[tag_i, index, n]
                        coi_obsm[:, :, n] = self.coi_obsm[tag_i, index, n]

                    for mc in range(0, self.max_copies):
                        circ_data = coi_obsm[seed, 0 : mc + 1, :].reshape(
                            *coi_obsm[seed, 0 : mc + 1, :].shape[:0], -1
                        )
                        x_data = train_obsm[seed, :, 0 : mc + 1, :].reshape(
                            *train_obsm[seed, :, 0 : mc + 1, :].shape[:1], -1
                        )
                        y_data = train_obsex[seed, :, 0]

                        try:
                            UNITED = self.vnCDRMitigation(circ_data, x_data, y_data)[0]
                        except:
                            print("vnCDR FAIL AT:", file=self.log_file)
                            print(
                                f"tag: {tag}, shot: {shot}, copy: {mc}, nlsp: NA, seed: {seed}",
                                file=self.log_file,
                            )
                            print(circ_data, x_data, y_data, file=self.log_file)

                            UNITED = [self.coi_obsex[tag_i, index, 0, seed]]
                        self.UNITED_array[tag_i][index][seed][mc] = UNITED[0]
                        self.UNITED_abs_error[tag_i][index][seed][mc] = abs(
                            UNITED[0] - self.coi_obsex[tag_i, index, 0, seed]
                        )
                    for mc in range(self.max_copies):
                        circ_data = coi_obsm[seed, 0, :].reshape(
                            *coi_obsm[seed, 0, :].shape[:0], -1
                        )
                        x_data = train_obsm[seed, :, 0, :].reshape(
                            *train_obsm[seed, :, 0, :].shape[:1], -1
                        )
                        y_data = train_obsex[seed, :, 0]
                        try:
                            UNITED = self.vnCDRMitigation(circ_data, x_data, y_data)[0]
                        except:
                            print("vnCDR FAIL AT:", file=self.log_file)
                            print(
                                f"tag: {tag}, shot: {shot}, copy: {mc}, nlsp: NA, seed: {seed}",
                                file=self.log_file,
                            )
                            print(circ_data, x_data, y_data, file=self.log_file)

                            UNITED = [self.coi_obsex[tag_i, index, 0, seed]]
                        self.vnCDR_array[tag_i][index][seed][mc] = UNITED[0]
                        self.vnCDR_abs_error[tag_i][index][seed][mc] = abs(
                            UNITED[0] - self.coi_obsex[tag_i, index, 0, seed]
                        )

                self.UNITED_cp_nlsp_dict[str(shot)]["mit_value" + tag] = pd.DataFrame(
                    self.UNITED_array[tag_i, index].transpose(),
                    columns=range(self.num_seeds),
                    index=range(1, self.max_copies + 1),
                )
                self.UNITED_cp_nlsp_dict[str(shot)]["abs_error" + tag] = pd.DataFrame(
                    self.UNITED_abs_error[tag_i, index].transpose(),
                    columns=range(self.num_seeds),
                    index=range(1, self.max_copies + 1),
                )
                self.vnCDR_cp_nlsp_dict[str(shot)]["mit_value" + tag] = pd.DataFrame(
                    self.vnCDR_array[tag_i, index].transpose(),
                    columns=range(self.num_seeds),
                    index=range(1, self.max_copies + 1),
                )
                self.vnCDR_cp_nlsp_dict[str(shot)]["abs_error" + tag] = pd.DataFrame(
                    self.vnCDR_abs_error[tag_i, index].transpose(),
                    columns=range(self.num_seeds),
                    index=range(1, self.max_copies + 1),
                )

    ### HELPER FUNCTIONS AND CALCULATIONS ###
    def f_lin(self, x, a0, a1):
        return a0 * x + a1

    def CDRMitigation(self, circ_data, training_data_real, training_data_sim):
        """
        Function that uses the training data to perform a regression and return the best fit variables
        """
        maskX = np.logical_or(
            np.isnan(training_data_real), ~np.isfinite(training_data_real)
        )  
        maskY = np.logical_or(
            np.logical_or(np.array(maskX, dtype=bool), np.isnan(training_data_sim)),
            ~np.isfinite(training_data_sim),
        ) 
        X_train = np.delete(training_data_real, maskY, axis=0)
        y_train = np.delete(training_data_sim, maskY, axis=0)
        reg = linear_model.LinearRegression(fit_intercept=True)
        X_test = circ_data
        reg.fit(X_train.reshape(-1, 1), y_train.reshape(-1, 1))
        corr = reg.predict(X_test.reshape(1, -1))
        return corr, []

    def vnCDRMitigation(self, circ_data, training_data_real, training_data_sim):
        maskX = np.logical_or(
            np.isnan(training_data_real), ~np.isfinite(training_data_real)
        )  
        maskY = np.logical_or(
            np.logical_or(
                np.array(maskX.sum(1), dtype=bool), np.isnan(training_data_sim)
            ),
            ~np.isfinite(training_data_sim),
        )  
        X_train = np.delete(training_data_real, maskY, axis=0)
        y_train = np.delete(training_data_sim, maskY, axis=0)
        reg = linear_model.LinearRegression(fit_intercept=True)
        X_test = circ_data
        reg.fit(X_train, y_train)
        corr = reg.predict(X_test.reshape(1, -1))
        return corr, []

    def CGVD_data(self):
        self.CGVD_dict = {}

        self.CGVD_array = np.zeros(
            (
                len(self.extra_tags),
                len(self.shots),
                len(self.nlsp_list),
                self.num_seeds,
                self.max_copies,
            )
        )
        self.CGVD_abs_error = np.zeros(
            (
                len(self.extra_tags),
                len(self.shots),
                len(self.nlsp_list),
                self.num_seeds,
                self.max_copies,
            )
        )
        for index, shot in enumerate(self.shots):
            self.CGVD_dict[str(shot)] = {}
            for tag_i, tag in enumerate(self.extra_tags):
                for nlsp_i, nlsp in enumerate(self.nlsp_list):
                    self.CGVD_dict[str(shot)][nlsp] = {}

        for index, shot in enumerate(self.shots):
            for tag_i, tag in enumerate(self.extra_tags):
                for nlsp_i, nlsp in enumerate(self.nlsp_list):

                    for seed in range(self.num_seeds):
                        for copies in range(self.max_copies):
                            train_obsex = np.zeros((self.num_seeds, self.train_use))
                            train_obsm = np.zeros(
                                (self.num_seeds, self.train_use, copies + 1)
                            )
                            coi_obsex = np.zeros((self.num_seeds))
                            coi_obsm = np.zeros((self.num_seeds, copies + 1))

                            train_obsex[:, :] = self.train_obsex[tag_i, index, nlsp_i]
                            train_obsm[:, :, :] = self.train_obsm[
                                tag_i, index, nlsp_i, :, :, 0 : copies + 1
                            ]
                            coi_obsex[:] = self.coi_obsex[tag_i, index, nlsp_i]
                            coi_obsm[:, :] = self.coi_obsm[
                                tag_i, index, nlsp_i, :, 0 : copies + 1
                            ]

                        for mc in range(self.max_copies):
                            circ_data = coi_obsm[seed, 0 : mc + 1].reshape(
                                *coi_obsm[seed, 0 : mc + 1].shape[:0], -1
                            )
                            x_data = train_obsm[seed, :, 0 : mc + 1].reshape(
                                *train_obsm[seed, :, 0 : mc + 1].shape[:1], -1
                            )
                            y_data = train_obsex[seed, :]
                            exact = coi_obsex.flatten()

                            try:
                                CGVD = self.vnCDRMitigation(circ_data, x_data, y_data)[
                                    0
                                ]
                            except:
                                print("CGVD FAIL AT:", file=self.log_file)
                                print(
                                    f"tag: {tag}, shot: {shot}, copy: {mc}, nlsp: {nlsp}, seed: {seed}",
                                    file=self.log_file,
                                )
                                print(circ_data, x_data, y_data, file=self.log_file)

                                CGVD = [self.coi_obsex[tag_i, index, nlsp_i, seed]]
                            self.CGVD_array[tag_i][index][nlsp_i][seed][mc] = CGVD[0]
                            self.CGVD_abs_error[tag_i][index][nlsp_i][seed][mc] = abs(
                                CGVD[0] - self.coi_obsex[tag_i, index, 0, seed]
                            )

                    self.CGVD_dict[str(shot)][nlsp]["mit_value" + tag] = pd.DataFrame(
                        self.CGVD_array[tag_i, index, nlsp_i].transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )

                    self.CGVD_dict[str(shot)][nlsp]["abs_error" + tag] = pd.DataFrame(
                        self.CGVD_abs_error[tag_i, index, nlsp_i].transpose(),
                        columns=range(self.num_seeds),
                        index=range(1, self.max_copies + 1),
                    )

    def safe_folder(self, dirName):
        if not os.path.exists(dirName):
            os.makedirs(dirName)
            print("Directory ", dirName, " Created ")
        else:
            print("Directory ", dirName, " already exists, might overwrite some plots")

    def nanMask(array1):
        nan_array = np.isnan(array1)
        not_nan_array = ~nan_array
        array2 = array1[not_nan_array]
        return array2

    def error_rescaling_factor(self, error_mitigated, exact, noisy):
        r_up = np.abs(error_mitigated)
        r_down = np.abs(noisy - exact).mean()
        r = r_up / r_down
        return r

    def build_panda(self):
        dataframes = []
        for tag_i, tag in enumerate(self.extra_tags):
            for index, shot in enumerate(self.shots):
                if self.train:
                    dataframes.append(
                        self.ZNE_lin2_dict[str(shot)]["abs_error" + tag]
                        .assign(type="ZNE" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="abs_error")
                    )
                    dataframes.append(
                        self.vnCDR_cp_nlsp_dict[str(shot)]["abs_error" + tag]
                        .assign(type="vnCDR" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="abs_error")
                    )
                    dataframes.append(
                        self.UNITED_cp_nlsp_dict[str(shot)]["abs_error" + tag]
                        .assign(type="UNITED" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="abs_error")
                    )
                    dataframes.append(
                        self.ZNE_lin2_dict[str(shot)]["mit_value" + tag]
                        .assign(type="ZNE" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="mit_value")
                    )
                    dataframes.append(
                        self.vnCDR_cp_nlsp_dict[str(shot)]["mit_value" + tag]
                        .assign(type="UNITED" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="mit_value")
                    )
                    dataframes.append(
                        self.UNITED_cp_nlsp_dict[str(shot)]["mit_value" + tag]
                        .assign(type="UNITED" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="mit_value")
                    )
                    dataframes.append(
                        self.exact_data_dict[str(shot)][1]["exact_value" + tag]
                        .assign(type="ZNE" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="exact_value")
                    )
                    dataframes.append(
                        self.exact_data_dict[str(shot)][1]["exact_value" + tag]
                        .assign(type="vnCDR" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="exact_value")
                    )
                    dataframes.append(
                        self.exact_data_dict[str(shot)][1]["exact_value" + tag]
                        .assign(type="UNITED" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                        .assign(res_type="exact_value")
                    )

                for noise_no, nlsp in enumerate(self.nlsp_list):
                    if self.train:
                        dataframes.append(
                            self.cdr_mit_dict[str(shot)][nlsp]["abs_error" + tag]
                            .assign(type="CDR" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                            .assign(res_type="abs_error")
                        )
                        dataframes.append(
                            self.CGVD_dict[str(shot)][nlsp]["abs_error" + tag]
                            .assign(type="CGVD" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                            .assign(res_type="abs_error")
                        )
                        dataframes.append(
                            self.CGVD_dict[str(shot)][nlsp]["mit_value" + tag]
                            .assign(type="CGVD" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                            .assign(res_type="mit_value")
                        )
                        dataframes.append(
                            self.cdr_mit_dict[str(shot)][nlsp]["mit_value" + tag]
                            .assign(type="CDR" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                            .assign(res_type="mit_value")
                        )
                        dataframes.append(
                            self.exact_data_dict[str(shot)][nlsp]["exact_value" + tag]
                            .assign(type="CDR" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                            .assign(res_type="exact_value")
                        )
                        dataframes.append(
                            self.exact_data_dict[str(shot)][nlsp]["exact_value" + tag]
                            .assign(type="CGVD" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                            .assign(res_type="exact_value")
                        )

                    dataframes.append(
                        self.VD_data_dict[str(shot)][nlsp]["mit_value" + tag]
                        .assign(type="VD" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=nlsp)
                        .assign(res_type="mit_value")
                    )
                    dataframes.append(
                        self.VD_data_dict[str(shot)][nlsp]["abs_error" + tag]
                        .assign(type="VD" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=nlsp)
                        .assign(res_type="abs_error")
                    )
                    dataframes.append(
                        self.exact_data_dict[str(shot)][nlsp]["exact_value" + tag]
                        .assign(type="VD" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=nlsp)
                        .assign(res_type="exact_value")
                    )
                    if self.density_matrices:
                        dataframes.append(
                            pd.DataFrame(
                                self.data_dict["coherent_mismatch"][tag][str(shot)][
                                    nlsp
                                ],
                                index=range(1, self.max_copies + 1),
                            )
                            .assign(type="coherent_mismatch" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                        dataframes.append(
                            pd.DataFrame(
                                self.data_dict["noise_floor"][tag][str(shot)][nlsp],
                                index=range(1, self.max_copies + 1),
                            )
                            .assign(type="noise_floor" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                        dataframes.append(
                            pd.DataFrame(
                                self.data_dict["eigenvalue_ratio"][tag][str(shot)][
                                    nlsp
                                ],
                                index=range(1, self.max_copies + 1),
                            )
                            .assign(type="eigenvalue ratio" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )

        cdf = pd.concat(dataframes)

        self.abs_error_df = pd.melt(
            cdf.reset_index(),
            id_vars=["index", "type", "shots", "nlsp", "res_type"],
            var_name=["seed"],
        )
        dataframes2 = []
        for tag_, tag in enumerate(self.extra_tags):
            for index, shot in enumerate(self.shots):

                if self.train:
                    dataframes.append(
                        self.ZNE_lin2_dict[str(shot)]["mit_value" + tag]
                        .assign(type="ZNE" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                    )
                    dataframes2.append(
                        self.vnCDR_cp_nlsp_dict[str(shot)]["mit_value" + tag]
                        .assign(type="UNITED" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                    )
                    dataframes2.append(
                        self.UNITED_cp_nlsp_dict[str(shot)]["mit_value" + tag]
                        .assign(type="UNITED" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=1)
                    )
                for noise_no, nlsp in enumerate(self.nlsp_list):
                    if self.density_matrices:

                        dataframes2.append(
                            pd.DataFrame(
                                self.data_dict["coherent_mismatch"][tag][str(shot)][
                                    nlsp
                                ],
                                index=range(1, self.max_copies + 1),
                            )
                            .assign(type="coherent_mismatch" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                        dataframes2.append(
                            pd.DataFrame(
                                self.data_dict["noise_floor"][tag][str(shot)][nlsp],
                                index=range(1, self.max_copies + 1),
                            )
                            .assign(type="noise_floor" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                        dataframes.append(
                            pd.DataFrame(
                                self.data_dict["eigenvalue_ratio"][tag][str(shot)][
                                    nlsp
                                ],
                                index=range(1, self.max_copies + 1),
                            )
                            .assign(type="eigenvalue ratio" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                    if self.train:
                        dataframes2.append(
                            self.CGVD_dict[str(shot)][nlsp]["mit_value" + tag]
                            .assign(type="CGVD" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                        dataframes2.append(
                            self.cdr_mit_dict[str(shot)][nlsp]["mit_value" + tag]
                            .assign(type="CDR" + tag)
                            .assign(shots=shot)
                            .assign(nlsp=nlsp)
                        )
                    dataframes2.append(
                        self.VD_data_dict[str(shot)][nlsp]["mit_value" + tag]
                        .assign(type="VD" + tag)
                        .assign(shots=shot)
                        .assign(nlsp=nlsp)
                    )

        cdf = pd.concat(dataframes2)

        self.standard_df = pd.melt(
            cdf.reset_index(),
            id_vars=["index", "type", "shots", "nlsp"],
            var_name=["seed"],
        )
        self.standard_df = self.standard_df.rename(columns={"index": "copies"})
        self.standard_df = self.standard_df.rename(columns={"value": "result"})
        self.abs_error_df = self.abs_error_df.rename(columns={"index": "copies"})
        self.abs_error_df = self.abs_error_df.rename(columns={"value": "abs_error"})
        type_list = ["VD", "UNITED", "CDR", "CGVD"]
        temp_list = []
        for tag_i, tag in enumerate(self.extra_tags):
            for index, shots in enumerate(self.shots):
                for noise_no, nlsp in enumerate(self.nlsp_list):
                    if self.train:
                        list_of_things = [
                            self.VD_data_dict[str(shots)][nlsp]["abs_error" + tag].mean(
                                1
                            ),
                            self.UNITED_cp_nlsp_dict[str(shots)][
                                "abs_error" + tag
                            ].mean(1),
                            self.cdr_mit_dict[str(shots)][nlsp]["abs_error" + tag].mean(
                                1
                            ),
                            self.CGVD_dict[str(shot)][nlsp]["abs_error" + tag].mean(1),
                        ]
                    else:
                        list_of_things = [
                            self.VD_data_dict[str(shots)][nlsp]["abs_error" + tag].mean(
                                1
                            )
                        ]

                    for method_i, method in enumerate(list_of_things):
                        for copies in range(1, self.max_copies + 1):
                            exact = self.coi_obsex[tag_i][index][noise_no]
                            noisy = np.array(
                                [
                                    self.coi_obsm[tag_i][index][noise_no][x][0]
                                    for x in range(len(self.coi_obsm[0][0][0]))
                                ]
                            )
                            r = self.error_rescaling_factor(
                                method[copies], exact, noisy
                            )
                            temp_list.append(
                                [type_list[method_i] + tag, copies, index, nlsp, r]
                            )
        self.calculated_vals_df = pd.DataFrame(
            temp_list,
            columns=["type", "copies", "shots", "nlsp", "error rescaling factor"],
        )


# %%
